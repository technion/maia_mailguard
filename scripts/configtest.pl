#!/usr/bin/perl

# $Id: configtest.pl 1570 2011-07-01 19:09:55Z rjl $

########################################################################
# MAIA MAILGUARD LICENSE v.1.0
#
# Copyright 2004 by Robert LeBlanc <rjl@renaissoft.com>
#                   David Morton   <mortonda@dgrmm.net>
# All rights reserved.
#
# PREAMBLE
#
# This License is designed for users of Maia Mailguard
# ("the Software") who wish to support the Maia Mailguard project by
# leaving "Maia Mailguard" branding information in the HTML output
# of the pages generated by the Software, and providing links back
# to the Maia Mailguard home page.  Users who wish to remove this
# branding information should contact the copyright owner to obtain
# a Rebranding License.
#
# DEFINITION OF TERMS
#
# The "Software" refers to Maia Mailguard, including all of the
# associated PHP, Perl, and SQL scripts, documentation files, graphic
# icons and logo images.
#
# GRANT OF LICENSE
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
#
# 1. Redistributions of source code must retain the above copyright
#    notice, this list of conditions and the following disclaimer.
#
# 2. Redistributions in binary form must reproduce the above copyright
#    notice, this list of conditions and the following disclaimer in the
#    documentation and/or other materials provided with the distribution.
#
# 3. The end-user documentation included with the redistribution, if
#    any, must include the following acknowledgment:
#
#    "This product includes software developed by Robert LeBlanc
#    <rjl@renaissoft.com>."
#
#    Alternately, this acknowledgment may appear in the software itself,
#    if and wherever such third-party acknowledgments normally appear.
#
# 4. At least one of the following branding conventions must be used:
#
#    a. The Maia Mailguard logo appears in the page-top banner of
#       all HTML output pages in an unmodified form, and links
#       directly to the Maia Mailguard home page; or
#
#    b. The "Powered by Maia Mailguard" graphic appears in the HTML
#       output of all gateway pages that lead to this software,
#       linking directly to the Maia Mailguard home page; or
#
#    c. A separate Rebranding License is obtained from the copyright
#       owner, exempting the Licensee from 4(a) and 4(b), subject to
#       the additional conditions laid out in that license document.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER AND CONTRIBUTORS
# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
# FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
# COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
# BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS
# OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
# ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR
# TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE
# USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
########################################################################

    use DBI;
    use File::Basename;
    use File::Copy;

    use constant COLUMN_1_WIDTH => 22;
    use constant COLUMN_2_WIDTH => 8;
    use constant MAIA_PATCH_PATH => '/usr/share/doc/maia-server/patches:/usr/share/doc/maiad/patches:/usr/share/doc/maia/patches';
    use constant PATCH_PATH => '.:' . MAIA_PATCH_PATH;

    # prototypes
    sub get_module_version($);
    sub print_message($$$);
    sub is_numeric($);
    sub decode_version_string($);
    sub get_single_value_from_db($$$);
    sub get_module_filepath($);

    # name of this script
    my $script_name = "configtest";

    # read configuration file (/etc/maia/maia.conf)
    my $config_file = "/etc/maia/maia.conf";
    unless (my $rv = do $config_file) {
        die("Maia: [$script_name] Couldn't parse $config_file: $@\n") if $@;
        die("Maia: [$script_name] Couldn't open $config_file\n") if (!defined($rv) || !$rv);
    };

    my @components = (
        {component => "Perl", type => "perl", regexp => "", minver => "5.008003",
         reason => "should never see this!"},

        {component => "file(1)", type => "file -v 2>&1", regexp => "\-([0-9\.]+)", minver => "4.24",
         reason => "required by Maia Mailguard"},

        {component => "Archive::Tar", type => "module", regexp => "", minver => "1.23",
         reason => "required by Maia Mailguard"},

        {component => "Archive::Zip", type => "module", regexp => "", minver => "1.14",
         reason => "required by Maia Mailguard"},

        {component => "BerkeleyDB", type => "module", regexp => "", minver => "",
         reason => "Maia Mailguard's optional caching feature requires this"},

        {component => "Compress::Zlib", type => "module", regexp => "", minver => "1.35",
         reason => "required by Maia Mailguard"},

        {component => "Convert::TNEF", type => "module", regexp => "", minver => "",
         reason => "required by Maia Mailguard"},

        {component => "Convert::UUlib", type => "module", regexp => "", minver => "1.08",
         reason => "required by Maia Mailguard"},

        {component => "Crypt::OpenSSL::RSA", type => "module", regexp => "", minver => "",
         reason => "SpamAssassin's optional DKIM plugin requires this"},

        {component => "Data::UUID", type => "module", regexp => "", minver => "",
         reason => "required by Maia Mailguard"},

        {component => "DB_File", type => "module", regexp => "", minver => "",
         reason => "required by SpamAssassin"},

        {component => "DBD::mysql", type => "module", regexp => "", minver => "2.9003",
         reason => "required if you use MySQL as your Maia Mailguard database"},

        {component => "DBD::Pg", type => "module", regexp => "", minver => "1.31",
         reason => "required if you use PostgreSQL as your Maia Mailguard database"},

        {component => "DBI", type => "module", regexp => "", minver => "1.40",
         reason => "required by Maia Mailguard and SpamAssassin"},

        {component => "Digest::MD5", type => "module", regexp => "", minver => "2.22",
         reason => "required by Maia Mailguard"},

        {component => "Digest::SHA", type => "module", regexp => "", minver => "",
         reason => "required by SpamAssassin"},

        {component => "Digest::SHA1", type => "module", regexp => "", minver => "",
         reason => "SpamAssassin's optional Razor2 plugin requires this"},

        {component => "Encode::Detect", type => "module", regexp => "", minver => "",
         reason => "SpamAssassin's optional normalize_charset feature requires this"},

        {component => "File::Spec", type => "module", regexp => "", minver => "0.80",
         reason => "required by SpamAssassin"},

        {component => "forks", type => "module", regexp => "", minver => "0.34",
         reason => "required by Maia Mailguard's process-quarantine tool"},

        {component => "HTML::Parser", type => "module", regexp => "", minver => "3.43",
         reason => "required by SpamAssassin"},

        {component => "HTTP::Date", type => "module", regexp => "", minver => "",
         reason => "SpamAssassin's sa-update script requires this"},

        {component => "IO::Stringy", type => "module", regexp => "", minver => "",
         reason => "required by Maia Mailguard"},

        {component => "IO::Socket::INET6", type => "module", regexp => "", minver => "",
         reason => "SpamAssassin requires this if your primary nameserver is only accessible via IPv6"},

        {component => "IO::Zlib", type => "module", regexp => "", minver => "1.04",
         reason => "SpamAssassin's sa-update script requires this"},

        {component => "IP::Country::Fast", type => "module", regexp => "", minver => "",
         reason => "SpamAssassin's optional RelayCountry plugin requires this"},

        {component => "libdb", type => "perl -e 'eval {require BerkeleyDB; print \$BerkeleyDB::db_version;}'", regexp => "", minver => "4.1.26",
         reason => "Optional features of SpamAssassin and Maia Mailguard use this"},

        {component => "LWP", type => "module", regexp => "", minver => "",
         reason => "SpamAssassin's sa-update script requires this"},

        {component => "Mail::Address", type => "module", regexp => "", minver => "",
         reason => "SpamAssassin's deprecated DomainKeys plugin requires this"},

        {component => "Mail::DKIM", type => "module", regexp => "", minver => "0.31",
         reason => "SpamAssassin's optional DKIM plugin requires this"},

        {component => "Mail::Internet", type => "module", regexp => "", minver => "1.58",
         reason => "required by Maia Mailguard"},

        {component => "Mail::SpamAssassin", type => "module", regexp => "", minver => "3.003000",
         reason => "required by Maia Mailguard"},

        {component => "Mail::SPF", type => "module", regexp => "", minver => "", 
         reason => "SpamAssassin's optional SPF plugin requires this"},

        {component => "MIME::Base64", type => "module", regexp => "", minver => "",
         reason => "required by Maia Mailguard and SpamAssassin"},

        {component => "MIME::Parser", type => "module", regexp => "", minver => "5.425",
         reason => "required by Maia Mailguard"},

        {component => "MIME::QuotedPrint", type => "module", regexp => "", minver => "3.03",
         reason => "required by Maia Mailguard"},

        {component => "Net::CIDR::Lite", type => "module", regexp => "", minver => "",
         reason => "SpamAssassin's optional SPF plugin requires this"},

        {component => "Net::Cmd", type => "module", avoid => "2.27",
         avoid_reason => "Net::Cmd 2.27 (libnet 1.20) incorrectly upgrades everything to UTF-8",
         reason => "part of libnet package, required by Maia Mailguard"},

        {component => "Net::DNS", type => "module", regexp => "", minver => "0.58",
         reason => "required by SpamAssassin"},

        {component => "Net::Server", type => "module", regexp => "", minver => "0.93",
         reason => "required by Maia Mailguard"},

        {component => "Net::SMTP", type => "module", regexp => "", minver => "",
         reason => "required by Maia Mailguard"},

        {component => "NetAddr::IP", type => "module", regexp => "", minver => "4.007",
         reason => "required by SpamAssassin"},

        {component => "Pod::Usage", type => "module", regexp => "", minver => "1.10",
         reason => "required by SpamAssassin"},

        {component => "Razor2::Client::Agent", type => "module", regexp => "", minver => "2.83",
         reason => "SpamAssassin's optional Razor2 module requires this"},

        {component => "Template", type => "module", regexp => "", minver => "2.10",
         reason => "required by Maia Mailguard"},

        {component => "Time::HiRes", type => "module", regexp => "", minver => "1.49",
         reason => "required by Maia Mailguard"},

        {component => "Unix::Syslog", type => "module", regexp => "", minver => "",
         reason => "required by Maia Mailguard"},

        {component => "URI", type => "module", regexp => "", minver => "",
         reason => "required by SpamAssassin"},

        {component => "Text::CSV", type => "module", regexp => "", minver => "",
         reason => "required by maiadbtool.pl"},

    );

    my @databases = (
	   {product => "MySQL Server", minver => "5.0.0",
	     verquery => "SELECT VERSION()", regexp => '^(\d+\.\d+\.\d+)'},
	
	    {product => "PostgreSQL Server", minver => "8.4", 
	     verquery => "SELECT VERSION()", regexp => '^PostgreSQL (\d+\.\d+\.\d+)'},
	
	);
	
    print "\nMAIA MAILGUARD CONFIGURATION TEST\n\n";

    print "This script checks for the presence of applications and Perl modules\n";
    print "required by maiad, SpamAssassin, and Maia Mailguard's maintenance\n";
    print "scripts.  Version numbers are also checked, and if a newer version of\n";
    print "a component is recommended, you should consider upgrading to at least\n";
    print "the minimum recommended version.\n\n";

    print "If you have already configured your Maia Mailguard database, the script\n";
    print "will also test the connection to that database.\n\n";

    print "Remember also to run the configtest.php script on your web server to\n";
    print "perform similar tests of your web, PHP, and PEAR environment.\n\n";

    printf("%-" . COLUMN_1_WIDTH . "s   %-" . COLUMN_2_WIDTH . "s   %s\n",
           "Application/Module", "Version", "Status");
    print "========================================================================\n";

    my $have_dbi = 0;
    my $have_dbd_mysql = 0;
    my $have_dbd_pg = 0;
    my $item;

    foreach $item (@components) {
        my %hash = %$item;
        my $component = $hash{"component"};
        my $type = $hash{"type"};
        my $regexp = $hash{"regexp"};
        my $min_version = $hash{"minver"};
        my $reason = $hash{"reason"};
        my $avoid_reason = $hash{"avoid_reason"};
        my $avoid = $hash{"avoid"};
        my $version = undef;
        my $upgrade = 0;
 
        # it's a Perl module, query its version number.
        if ($type eq "module") {
	        eval {
               $version = get_module_version($component);
            };

        # it's Perl itself, so determine its version number directly.
        } elsif ($type eq "perl") {
            $version = $];

        # it's an external app, invoke its version-printing command
        # and grab the result with an app-specific regular expression.
        } else {
	        eval {
               $version = `$type`;
               if ($regexp ne "") {
                  $version = (($version =~ /$regexp/si) ? $1 : undef);
               }
            };
        }
        $hash{"version"} = $version;

        # is an upgrade recommended?
        if (defined $version && $min_version ne "") {
            if (is_numeric($version) && is_numeric($min_version)) {
                $upgrade = $version < $min_version;
            } else {
                $upgrade = $version lt $min_version;
            }
        }

        if (defined $version && $version ne "") {
            $version = decode_version_string($version);
            $min_version = decode_version_string($min_version);
            if ($version eq $avoid) {
                print_message($component, $version, "AVOID $min_version : $avoid_reason");
            } elsif ($upgrade) {
                print_message($component, $version, "UPGRADE RECOMMENDED (minimum version $min_version)");
            } else {
                print_message($component, $version, "OK");
            }
            $have_dbi = 1 if ($component eq "DBI");
            $have_dbd_mysql = 1 if ($component eq "DBD::mysql");
            $have_dbd_pg = 1 if ($component eq "DBD::Pg");
        } else {
            print_message($component, "N/A", "NOT INSTALLED ($reason)");
        }
    }

    if ($have_dbi && ($have_dbd_mysql || $have_dbd_pg)) {

        my $dbh, $dbtype, $dbversion;

        # database tests
        if (defined($dsn) && defined($username) && defined($password)) {
            for ($dsn) {
               /^DBI:mysql:/i and do {$dbtype = 'MySQL Server'; last;};
               /^DBI:Pg:/i    and do {$dbtype = 'PostgreSQL Server'; last;};
               /^DBI:(.+?):/i  and die(sprintf("%-" . COLUMN_1_WIDTH . "s : %s\n\n", 
                                               "Database DSN test", "FAILED " .
	                                           "(unsupported database type '$1')"));
            }
            $dbh = DBI->connect($dsn, $username, $password)
                or die(sprintf("%-" . COLUMN_1_WIDTH . "s : %s\n\n", 
                               "Database DSN test", "FAILED " .
                               "(verify \$dsn, \$username, and \$password in $config_file)"));
        } else {
            die(sprintf("%-" . COLUMN_1_WIDTH . "s : %s\n\n", 
                        "Database DSN test", "FAILED " .
                        "(missing \$dsn, \$username, or \$password in $config_file)"));
        }

        foreach my $db (@databases) {
           next if ($db->{product} ne $dbtype);

           $dbversion = get_single_value_from_db($dbh, $db->{verquery}, $db->{regexp});
           if (!defined($dbversion)) {
              printf("%-" . COLUMN_1_WIDTH . "s : %s", $dbtype,
                     "Connection OK, but version information could not be determined");
           } else {

              $dbversion = sprintf("%s", $dbversion);
              $db->{version} = $dbversion;
  
              # Do we need to upgrade MySQL/PostgreSQL?
              my $dbupgrade = 0;
              if (defined($db->{minver}) && $db->{minver} ne "") {
	             $db->{minver} = sprintf("%s", $db->{minver});
                 $dbupgrade = $dbversion < $db->{minver};
              }

              # Do we need to warn about this version of MySQL/PostgreSQL?
              my $dbwarn = 0;
              if (defined($db->{conditions})) {
	             $dbwarn = all_conditions_met($db->{conditions});
              }

              if ($dbupgrade) {
                 print_message($dbtype, $dbversion, "UPGRADE REQUIRED (minimum version " . $db->{minver} . ")");
	          } elsif ($dbwarn) {
                 print_message($dbtype, $dbversion, "WARNING : " . $db->{warning});
              } else {
                 print_message($dbtype, $dbversion, "OK");
              }
           }
        }

        # Disconnect from the database
        $dbh->disconnect;

        printf("%-" . COLUMN_1_WIDTH . "s : %s\n", "Database DSN test", "PASSED");

    } else {
    	print("Database tests SKIPPED (missing DBI and/or DBD modules)\n");
    }

    print "\n";
    exit;


    # Returns the version number of the named module, or undef if the module
    # is not installed.
    sub get_module_version($) {
        my($module) = @_;

        my $version = `$^X -m$module -e 'print \$${module}::VERSION' 2>/dev/null`;
        $version =~ s/^\s*(.*?)\s*$/$1/;
        return ($version || undef);
    }


    # Returns the contents of a single database column from a single row
    # determined by the given SQL SELECT query.  If a regex pattern is
    # also supplied, the first sub-match of the result is returned instead.
    sub get_single_value_from_db($$$) {
	    my($dbh, $query, $pattern) = @_;
        my $value = undef;
	
	    if (defined($dbh)) {
		   my $sth = $dbh->prepare($query)
		         or die("Failed to prepare query: " . $dbh->errstr);
		   $sth->execute()
		         or die("Failed to execute query: " . $dbh->errstr);
		   if (my @row = $sth->fetchrow()) {
			   if (defined($pattern)) {
                  $value = $1 if $row[0] =~ /$pattern/i;
               } else {
	              $value = $row[0];
               }	
		   }
		   $sth->finish;
	    }
	
	    return $value;
    }


    # Prints a formatted text message.
    sub print_message($$$) {
        my($module, $version, $message) = @_;

        printf("%-" . COLUMN_1_WIDTH . "s : %" . COLUMN_2_WIDTH . "s : %s\n", $module, $version, $message);
    }


    # Returns true if a string is a valid, non-negative integer or floating point value.
    sub is_numeric($) {
        my ($string) = @_;

        return ($string =~ /^\d+(\.\d+)?$/);
    }


    # Convert standard M.mmmttt version numbers to M.m.t format 
    # for display purposes.
    sub decode_version_string($) {
        my ($version) = @_;
        my ($major, $minor, $trivial);

        # strip any leading or trailing non-digits/decimals
        $version =~ s/[^\d]*([\d\.]+)[^\d]*/$1/g;

        if ($version =~ /^([0-9]+)\.([0-9]{3})([0-9]{3})$/) {
           $major = int($1);
           $minor = int($2);
           $trivial = int($3);
           return ($major . "." . $minor . "." . $trivial);
        } else {
           return $version;
        }
    }


    # Tests all of the conditions associated with a component
    # and returns 1 if all of the conditions have been met.
    sub all_conditions_met($) {
	    my ($conditions_list) = @_;
        my $result = undef;

        if (defined($conditions_list)) {
            my @conditions = @{$conditions_list};
            my $conditions_met = 0;
            foreach my $condition (@conditions) {
               my $met = test_condition($condition);
               $conditions_met++ if (defined($met) && $met);
            }
            $result = ($conditions_met == scalar(@conditions) ? 1 : 0);
        }

        return $result;
    }


    # Tests a condition of the form 'Component [<=>!] Version'
    # where the component may be any of the known components
    # or databases, and the test itself can be '<'. '<=', '=',
    # '>=', '>' or '!='.
    sub test_condition($) {
	    my($condition) = @_;
	    my $result;
	
	    if ($condition =~ /^(.+) (<|<=|=|>=|>|!=) ([\d\.]+)$/) {
		   my $test_component = $1;
		   my $test_equality = $2;
		   my $test_version = $3;
		   my $component_version = undef;
		
		   foreach my $c (@components) {
		      next if ($c->{component} ne $test_component);
		      $component_version = $c->{version};
		      last;	
		   }
		   if (!defined($component_version)) {
		      foreach my $d (@databases) {
			     next if ($d->{product} ne $test_component);
			     $component_version = $d->{version};
			     last;
		      }	
		   }
		   for ($test_equality) {
		      /^<$/  and do {$result = ($component_version lt $test_version); last;};
		      /^<=$/ and do {$result = ($component_version le $test_version); last;};
		      /^=$/  and do {$result = ($component_version eq $test_version); last;};
		      /^>=$/ and do {$result = ($component_version ge $test_version); last;};
		      /^>$/  and do {$result = ($component_version gt $test_version); last;};
		      /^!=$/ and do {$result = ($component_version ne $test_version); last;};	
		   }
	    }

	    return $result;
    }


    # Tests for the existence and readability of a file in each
    # of the directories listed in the supplied path, returning
    # the full filepath of the first successful search.
    sub find_file_in_path($$) {
	    my ($file, $path) = @_;
	
	    my @dirs = split(':', $path);
	    foreach my $dir (@dirs) {
		   my $filepath = $dir . '/' . $file;
		   if (open(TEST, "<", $filepath)) {
		      close(TEST);
		      return dirname($filepath) . '/' . basename($filepath);
		   }
	    }
	
	    return undef;
    }


	# Returns the full file path of an installed Perl module
	sub get_module_filepath($) {
		my ($module) = @_;
		my $file_path = undef;

		$module =~ s/::/\//g; # convert :: to /
		$module .= '.pm';
		eval {
		   require $module;
		   $file_path = $INC{$module};
		};

		return $file_path;
	}


